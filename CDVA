function [CR, CI, CR_archive, PopArchive] = ...
    VariableClustering_MB_Constraint_Archive( ...
        Population, CR_archive, PopArchive, gen, MaxDVAgen)
% MB-based constraint DVA with population archive
% - Stores evaluated populations during early evolution
% - Uses archived data for MB learning
% - Accumulates CR variables
% - ALWAYS outputs CR and CI

    %% Parameters
    FeasibleThreshold = 0.8;   % stop DVA if most solutions are feasible
    MinSamples       = 20;    % minimum samples for MB

    %% Extract current population
    X = Population.decs;     % N x D
    G = Population.cons;     % N x K
    [N, D] = size(X);

    %% Compute constraint violation
    CV = sum(max(0, G), 2);

    %% Check feasibility ratio
    feasible_ratio = mean(CV == 0);

    %% Decide whether DVA is active
    DoDVA = (gen <= MaxDVAgen) && (feasible_ratio < FeasibleThreshold);

    %% Update population archive (only while DVA is active)
    if DoDVA
        PopArchive.X  = [PopArchive.X;  X];
        PopArchive.CV = [PopArchive.CV; CV];
    end

    %% Perform MB-based DVA on archived data
    if DoDVA && size(PopArchive.X, 1) >= MinSamples

        CVa = PopArchive.CV;
        Xa  = PopArchive.X;

        %% Normalize CV
        CVnorm = (CVa - min(CVa)) ./ (max(CVa) - min(CVa) + eps);

        %% Extreme CV sampling
        cv_thresh = prctile(CVnorm, [30 70]);
        mask = (CVnorm <= cv_thresh(1)) | (CVnorm >= cv_thresh(2));

        if sum(mask) >= MinSamples
            labels = double(CVnorm(mask) >= cv_thresh(2));
            X_mb   = Xa(mask, :);

            %% Markov Blanket analysis
            CR_new = MBAnalysis([X_mb, labels], D);

            %% Accumulate CR
            CR_archive = unique([CR_archive, CR_new]);
        end
    end

    %% Final outputs (always defined)
    CR = CR_archive(:)';
    CI = setdiff(1:D, CR);

end
